复制算法
===
将内存划分为大小相等的两块,每次只使用其中的一块,当这一块用完的时候,将存货的对象复制到另一块,然后再把使用过的内存空间一次清理掉,这样对整个区域进行回收,内存分配也不用考虑碎片问题,只要移动堆指针,顺序分配即可.

实现简单,运行高效.

不足:
* 内存缩小为一半,代价高.
* 对象存活率高时,较多复制,效率变低.不适合老年代.

----
现在商业虚拟机采用这种算法.

将内存分为一块大的Eden空间和两个小的Survivor空间,**每次使用Eden和一块Survivor**.当回收时,将Eden和Survivor中对象一次复制到另一块Survivor空间中,最后清理掉Eden和Survivor空间.当Survivor空间**不够使用**时,需要依赖其他内存(老年代)进行**分配担保**.

默认比例8:1,只有10%被浪费.

