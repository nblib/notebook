总结
===
#### 垃圾收集器
###### 年轻代
* Serial
* ParNew
* Parallel
###### 老年代
* CMS
* Serial Old
* Parallel Old

关系图:
[关系图](垃圾收集器关系图.png)


> G1 同时包括年轻和老年代.

###### 相互配合
见关系图

##### Serial收集器
###### 特点
* 单线程收集器
* 一个CPU,一个线程,同时停止其他所有工作线程.
* 虚拟机Client模式下的默认新生代收集器
* 单CPU环境下简单高效

---
##### ParNew收集器
###### 特点
* Serial多线程版本
* 收集算法,对象分配原则,回收策略和Serial相同
* Server模式下的首选新生代收集器
* 除了Serial,它是唯一能和CMS收集器配合的新生代

---
##### Parallel Scavenge收集器
###### 特点
* 新生代,复制算法
* 并行
* 目标是达到一个可控制的吞吐量.
* 适合后台运算不需要太多交互的任务
* 有自适应调节策略

---
##### Serial Old收集器
###### 特点
* 单线程,Seral的老年版本
* 使用"标记-整理'算法
* 主要供Client模式使用
* Server模式下,用于1.5版本以前和Parallel Scavenge配合和作为CMS后备预案

---
##### Parallel Old 收集器
###### 特点
* Parallel Scavenge收集器老年版本
* 多线程和'标记-整理'算法
* 适合在注重吞吐量和CPU资源敏感的场合和Parallel Scavenge 配合使用.

---
##### CMS收集器
###### 特点
* 以获取最短停顿时间为目标
* 适合网站/BS结构的服务端
* 基于标记-清除算法,过程分为
* 1. 初始标记
* 2. 并发标记
* 3. 重新标记
* 4. 并发清除
* 初始标记和重新标记需要StopWorld,重新标记时间比初始长,远比并发标记短
* 最费时的过程和用户线程并发执行,可以说是并发回收的.
* 对cpu资源敏感.默认回收线程数是(cpu数量+3)/4 ,cpu越多,越好
* 无法处理浮动垃圾
* 
> 浮动垃圾
并发标记的时候,用户线程还在执行,标记完成后,还会有垃圾存在,这部分垃圾就是浮动垃圾.
* 由于浮动垃圾的产生,不能等到内存满了再收集,而是预留一部分给浮动垃圾,JDK1.6以后,当使用了92%时,开始并发收集.
* 基于标记清理算法,会产生碎片,当不足以分配大对象时,避免full GC,CMS会开启碎片整理,**这个 阶段不能并发执行**
* 
---
##### G1 收集器
###### 特点
* 面向服务端应用的垃圾收集器
* 并发与并行: 利用多核优势,使用多个CPU减少STW停顿时间.
* 分代: 可以不需要其他收集器配合,独立管理堆.
* 空间整合: 整体像是标记-整理,局部使用"复制"算法
* 可预测停顿: 能让使用者指定在指定的M时间片段内,垃圾收集不超过N毫秒.
* 阶段可分为:
    1. 初始标记
    2. 并发标记
    3. 最终标记
    4. 筛选回收
* 将内存分为区域(Region),新生代和老年代,只是逻辑上的区分.每一个Region对应一个Remembered Set.

---