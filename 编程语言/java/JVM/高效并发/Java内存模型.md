Java内存模型
===
* 方法局部变量和方法参数属于线程私有,不会被共享
* 所有变量存在主内存中
* 每条线程有自己的工作内存,工作内存互相独立,不共享
* 局部变量是一个引用类型,引用的对象在堆中被各个线程共享,但是引用本身在java栈的局部变量表中,线程私有
* volatile变量也有工作内存的拷贝,但它有特殊的操作顺序规定.
* 主内存和工作内存交互8种操作:
    * lock: 作用于主内存变量,标识为线程独占状态.
    * unlock: 作用于主内存的变量,把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定.
    * read: 作用于主内存,从主内存传送到工作内存
    * load: 作用于工作内存的变量,把read得到的变量放入到工作内存的副本中.
    * use: 工作内存,把变量值传递给执行引擎,每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作.
    * assign: 工作内存, 把一个执行引擎接受到的值赋值给工作变量,每当虚拟机遇到给变量赋值的字节码指令的时候执行这个操作.
    * store: 工作内存,把工作内存的变量传递到主内存.
    * write: 主内存,把store操作从工作内存得到的变量值放到主内存的变量中.
* 8中操作的规则:
    * read和load,sotre和write顺序执行,但不一定连续.
    * read和load,store和write不允许单一出现.
    * 不允许一个线程丢弃它最近的assign操作,变量在工作内存中改变后必须同步到主内存中.
    * 不允许线程无原因的(没有发生过assign操作)把数据同步到主内存中.
    * 一个新的变量只能在主内存中诞生,不允许工作内存使用未被初始化的变量.对一个变量实施use,store操作之前,必须先执行过assign和load操作.
    * 一个变量同一时刻只允许一条线程执行lock操作,但lock操作可以被重复执行多次,多次lock后,只有执行相同次数的unlock操作,变量才会被解锁.
    * 如果对一个变量执行lock操作,会清空工作内存中此变量的值,在执行引擎使用这个变量之前,需要重新执行load或assign操作初始化变量的值.
    * 变量没有被lock,不允许对它执行unlock操作.
    * 对一个变量执行unlock操作之前,必须先把此变量同步会主内存中
* volatile的特殊规则:
    * 前一个动作load,才能对变量执行use操作;并且,后一个动作时use时,才能执行load操作,保证使用时获取最新的值.
    * 前一个动作是assign的时候,才能执行store动作;后一个动作是store时,才能执行assign操作,保证每次修改后,必须同步回主内存中
    * 对一个变量use或assign操作优先于另一个变量的操作,那么对这个变量的read和write操作也优先于对另一个变量的操作.,保证变量指令不会被重排优化,保证代码的执行顺序和程序的顺序相同.
* long和double变量的特殊规则:
    * 允许虚拟机将没有被volatile休书的64为数据类型的读写操作划分为两次32位的操作执行,即不保证load,store,read和write4个操作的原子性.